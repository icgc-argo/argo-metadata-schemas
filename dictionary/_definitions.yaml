$schema: "http://json-schema.org/draft-07/schema#"

$id: _definitions

common:
  type: object
  properties:
    id:  # surrogate key generated by system
      type: string
      pattern: "^[A-Z]{2}[0-9]+$"
      readOnly: true  # this makes `id` immutable once created
    submitter_id:
      type: string
      pattern: "^[a-zA-Z]{1}[a-zA-Z0-9_-.:']*[a-zA-Z0-9]{1}$"
    date:
      type: string
      format: date
    date_time:
      type: string
      format: date-time
    uuid:  # surrogate key generated by system
      type: string
      pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
      readOnly: true  # immutable once created
    bundle_status:
      enum:
      - "registered"  # Entity's metadata submitted, validated and stored on the server
      - "uploaded"  # All files in the bundle uploaded and stored on the server
      - "upload_failed"  # One or more files in the bundle failed uploading
      - "published"  # User or admin published the bundle (only possible after all files uploaded)
      - "suppressed"  # User or admin suppressed the bundle (no file in the bundle can be downloaded). Admin can re-publish a suppressed bundle
      - "depreciated"  # This is like 'mark deleted', bundle is depreciated but still accessible, files can not be downloaded (could have been purged from the server)
    program_short_name:
      enum:  # this lists all ARGO program's short names, dummy examples here for now
      - PACA-CA
      - PRAD-CA
      - PBCA-DE

submitted_file:
  type: object
  required: [ name, local_path, size, checksum, checksum_type ]
  allOf:
  - properties:
      name:  # if omitted, name will be original file name from local_path
        type: string
        pattern: "^[A-Za-z0-9_-]{1}[A-Za-z0-9_-.]{0,199}"  # max length 200 chars
      local_path:  # fullpath includes path and file name
        type: string
      size:
        type: integer
        minimum: 0
      checksum:
        type: string
      checksum_type:
        enum: [ md5, sha256, sha512 ]
  - oneOf:
    - properties:
        name:
          pattern: "\.bam$"
        format:
          const: BAM
    - properties:
        name:
          pattern: "\.bam\.bai$"
        format:
          const: BAI
    - properties:
        name:
          pattern: "\.cram$"
        format:
          const: CRAM
    - properties:
        name:
          pattern: "\.cram\.crai$"
        format:
          const: CRAI
    - properties:
        name:
          pattern: "\.fastq\.gz$"
        format:
          const: FASTQ
    - properties:
        name:
          pattern: "\.fq\.gz$"
        format:
          const: FASTQ
    - properties:
        name:
          pattern: "\.vcf\.gz$"
        format:
          const: VCF
    - properties:
        name:
          pattern: "\.vcf\.gz\.tbi$"
        format:
          const: TBI
    - properties:
        name:
          pattern: "\.tgz$"
        format:
          const: TGZ
    - properties:
        name:
          pattern: "\.fa.gz$"  # created by bgzip
        format:
          const: FASTA
    - properties:
        name:
          pattern: "\.fa\.gz\.fai$"
        format:
          const: FAI
    - properties:
        name:
          pattern: "\.fasta.gz$"  # created by bgzip
        format:
          const: FASTA
    - properties:
        name:
          pattern: "\.fasta\.gz\.fai$"
        format:
          const: FAI
    - properties:
        name:
          pattern: "\.txt\.gz$"
        format:
          const: TXT
    - properties:
        name:
          pattern: "\.tsv\.gz$"
        format:
          const: TSV
    - properties:
        name:
          pattern: "\.csv\.gz$"
        format:
          const: CSV
    - properties:
        name:
          pattern: "\.pdf\.gz$"
        format:
          const: PDF
    - properties:
        name:
          pattern: "\.png$"
        format:
          const: PNG

data_object:
  type: object
  properties:
    id:
      $ref: "#/common/properties/uuid"
    data_type:
      oneOf:  # not necessarily we do this hybrid way, just to show case the possibilities JSON Schema gives us
      - const: SSM  # acronym, good as facet terms
        title: "Simple Somatic Mutations"  # short title, good for displaying as tooltip
      - const: CNSM
        title: "Copy Number Somatic Mutations"
      - const: StSM
        title: "Structural Somatic Mutations"
      - const: SGV
        title: "Simple Germline Variations"
      - const: StGV
        title: "Structural Germline Variations"
      - enum:  # data types with no acronym
        - "Sequencing Reads"
        - "Unaligned Sequencing Reads"
        - "Aligned Sequencing Reads"
        - "Aligned Sequencing Reads Index"
        - "Read Group QC Metrics"
        - "Alignment QC Plot"
        - "Alignment QC Metrics"
    repository:
      enum:
      - Collab
      - DKFZ

repositoryProperties:  # this should probably be outsourced to somewhere else, but it demonstrates how this could be done in JSON Schema
  oneOf:
  - properties:
      program:
        allOf:
        - $ref: "#/common/properties/program_short_name"
        - enum: [ "PACA-CA", "PRAD-CA" ]
      respository:
        allOf:
        - $ref: "#/data_object/properties/respository"
        - enum: [ "Collab" ]
  - properties:
      program:
        allOf:
        - $ref: "#/common/properties/program_short_name"
        - enum: [ "PBCA-DE" ]
      respository:
        allOf:
        - $ref: "#/data_object/properties/respository"
        - enum: [ "DKFZ" ]
